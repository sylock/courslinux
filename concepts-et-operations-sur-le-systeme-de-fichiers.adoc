==  Concepts et opérations sur le système de fichiers

// d'abord voir les différentes commandes et parler des . et .. après - idem pour chemins relatifs et absolus

===  Le répertoire spécial nommé ..

Le noyaux Linux crée automatiquement, pour chaque répertoire du système, un répertoire spécial qui facilite la navigation.
Le répertoire "point, point" permet de se déplacer dans le répertoire parent.
Dans l'exemple suivant, nous nous trouvons toujours dans la home directory de l'utilisateur titi.
L'utilisation du répertoire "deux-point" en argument à la commande cd nous permet de nous déplacer dans le répertoire qui se trouve un niveau au-dessus dans la hiérarchie du système de fichier, /home.

.Remonter au répertoire parent
[source, console]
----
$ pwd
/home/titi
$ cd ..
$ pwd
/home
----

===  Le répertoire spécial nommé .

Le « point » simple désigne le répertoire courant, c'est à dire le répertoire dans lequel on se trouve actuellement.

.Se déplacer dans le répertoire courant nous amène ... au même endroit!
[source, console]
----
$ pwd
/home/titi
$ cd .
$ pwd
/home/titi
----

=== Les chemins relatifs et absolu

On distingue deux façons de spécifier un chemin :
Relatif : il est construit à partir du répertoire courant (qu'on peut connaître avec la commande pwd)
Absolu : il démarre de la racine (/).
Un chemin absolu commencera donc toujours par un « / ».
Le seul objectif est de vous faciliter la vie en diminuant la quantité de caractères à taper au clavier.
On utilisera l'une ou l'autre méthode en fonction de son emplacement actuel et de la destination souhaitée.
Dans certain cas, la longueur du chemin sera plus courte avec un chemin absolu, dans d'autres avec un chemin relatif.

NOTE: Les deux méthodes permettent toujours d'arriver à la même destination. Seule la longueur du chemin à taper changera.

Admettons que je me trouve dans le répertoire /usr.
Si je souhaite me rendre dans le répertoire /usr/games, le plus simple est d'utiliser un chemin relatif.

==== Premier exemple

.Se déplacer depuis /usr vers /usr/games au moyen d'un chemin relatif
[source, console]
----
$ pwd
/usr
$ cd games
$ pwd
/usr/games
----

.Déplacement relatif schématisé
[graphviz, "figures/chemin-relatif-1", svg]
----
digraph paths {
        graph [overlap = false];
        node [shape=folder];

		usr[color=red]
		"/"  -> { usr lib root home } [arrowhead=none];
		home -> { toto x41} [arrowhead=none];
		usr -> { games bin usrlib[label=lib] } [arrowhead=none];

		usr  -> games [headlabel=" cd games" color=blue fontcolor=blue tailport=w headport=n labeldistance=5 labelangle=40];

		{ rank=same; usr; lib ; root ; home }
		{ rank=same; x41; toto ; games ; bin ; usrlib }
}
----

Pour obtenir le même résultat en écriture absolue, nous aurions dû entrer cette suite de commandes.

.Déplacement absolu schématisé
[source, console]
----
$ pwd
/usr
$ cd /usr/games
$ pwd
/usr/games
----

Remarquez la différence: en relatif nous avions `cd games`, en absolu nous avons `cd /usr/games`.

.Se déplacer depuis /usr vers /usr/games au moyen d'un chemin absolu
[graphviz, "figures/chemin-absolu-1", svg]
----
digraph paths {
        graph [overlap = false];
        node [shape=folder];

		usr[color=red]
		"/"  -> { usr lib root home } [arrowhead=none];
		home -> { toto x41} [arrowhead=none];
		usr -> { games bin usrlib[label=lib] } [arrowhead=none];

        "/"  -> games [headlabel=" cd /usr/games" color=blue fontcolor=blue tailport=w headport=n labeldistance=9 labelangle=25];

		{ rank=same; usr; lib ; root ; home }
		{ rank=same; x41; toto ; games ; bin ; usrlib }
}
----

Si nous résumons les deux stratégies pour ce cas de figure, la méthode relative permet d'obtenir le même résultat avec 8 caractères au lieu de 13 pour la méthode absolue.

.Comparatif entre le chemin relatif et absolu
|===
|Méthode|Commande|Nombre de caractères

|Relatif
|`cd games`
|8

|Absolu
|`cd /usr/games`
|13
|===

==== Deuxième exemple

Je me trouve toujours dans le répertoire /usr et je souhaite me rendre dans /root.
Essayons en chemin relatif.

.Déplacement depuis /usr vers /root avec un chemin relatif
[source, console]
----
$ pwd
/usr
$ cd ../root
$ pwd
/root
----

.Se déplacer depuis /usr vers /root au moyen d'un chemin relatif
[graphviz, "figures/chemin-relatif-2", svg]
----
digraph paths {
        graph [overlap = false];
        node [shape=folder];

		usr[color=red]
		"/"  -> { usr lib root home } [arrowhead=none];
		home -> { toto x41} [arrowhead=none];
		usr -> { games bin usrlib[label=lib] } [arrowhead=none];

        "/"  -> usr [headlabel=" cd .." dir=back color=blue fontcolor=blue tailport=w headport=n labeldistance=3 labelangle=40];
        "/"  -> root [headlabel=" cd root" color=blue fontcolor=blue tailport=e headport=n labeldistance=3 labelangle=-40];

		{ rank=same; usr; lib ; root ; home }
		{ rank=same; x41; toto ; games ; bin ; usrlib }
}
----

NOTE: On aurait pu faire cette manipulation en deux commandes : +
`$ pwd` +
`/usr` +
`$ cd ..` +
`$ cd root` +
Dans l'exemple, plutôt que d'avoir utilisé deux fois la commande cd, nous l'avons utilisé une seule fois en spécifiant le `..` d'abord et le `root` ensuite, séparé par le slash :
`../root`, afin d'économiser le nombre de caractères.

Le même déplacement en chemin absolu aurait donné ceci.

.Déplacement depuis /usr vers /root avec un chemin absolu
[source, console]
----
$ pwd
/usr
$ cd /root
$ pwd
/root
----

.Se déplacer depuis /usr vers /root au moyen d'un chemin absolu
[graphviz, "figures/chemin-absolu-2", svg]
----
digraph paths {
    graph [overlap = false];
    node [shape=folder];

    usr[color=red]
    "/"  -> { usr lib root home } [arrowhead=none];
    home -> { toto x41} [arrowhead=none];
    usr -> { games bin usrlib[label=lib] } [arrowhead=none];

    "/"  -> root [headlabel=" cd /root" color=blue fontcolor=blue tailport=e headport=n labeldistance=4 labelangle=-40];

    { rank=same; usr; lib ; root ; home }
  { rank=same; x41; toto ; games ; bin ; usrlib }
}
----

Dans ce cas et contrairement au premier exemple, la méthode absolue est la plus courte.

.Comparatif entre le chemin relatif et absolu
|===
|Méthode|Commande|Nombre de caractères

|Relatif
|`cd ../root`
|10

|Absolu
|`cd /root`
|8
|===

=== cd et les arguments spéciaux
Dans tous les exemples que nous venons de voir, nous avons toujours donné comme argument à la commande cd, un chemin, qu'il soit relatif ou absolu.

==== cd sans argument
Il est possible d'utiliser « cd » sans aucun argument.
Auquel cas, nous nous déplaçons dans la home directory de l'utilisateur courant.
Si je suis connecté avec l'utilisateur "titi" et que je me trouve initialement à la racine du système de fichier, utiliser "cd" me déplace dans ma home directory.

.cd sans argument déplace dans la home directory
[source, console]
----
$ pwd
/
$ cd
$ pwd
/home/titi
----

==== cd \~
Il est également possible d'utiliser le tilde pour obtenir le même résultat.
Le tilde est le caractère en forme de vague \~ se trouvant sur la touche = d'un clavier belge.
Pour pouvoir le former, faites ALT GR + "="" suivi d'un appui sur la barre d'espacement.

.cd suivit du tilde déplace également dans la home directory
[source, console]
----
$ pwd
/
$ cd ~
$ pwd
/home/titi
----

L'attrait principal du tilde est qu'il peut-être concaténé (collé) au nom d'un utilisateur, auquel cas le shell l’interprète comme une représentation de la home directory de l'utilisateur spécifié et plus de l'utilisateur courant.
Dans l'exemple ci-dessous, l'utilisateur titi se déplace dans la home directory de l'utilisateur toto.

.Le tilde suivit d'un nom d'utilisateur déplace dans la home directory de l'utilisateur spécifié
[source, console]
----
$ whoami # Permet de connaître l'utilisateur courant
titi
$ pwd
/home/titi
$ cd ~toto
$ pwd
/home/toto
----

==== cd -

Le tiret (ou dash en anglais) permet de se déplacer dans le répertoire précédent (attention, précédent ne veut pas dire parent!).
C'est une sorte d'historique.

.Le tiret permet de retourner au répertoire courant précédent
[source, console]
----
$ pwd
/usr/games
$ cd /lib/modules
$ pwd
/lib/modules
$ cd -
$ pwd
/usr/games
----

==== touch

Cette commande, utilisée sur un répertoire ou fichier existant, met à jours le timestamp
footnote::[Un timestamp est traduit par « horodatage » en français. Voici ce que wikipédia en dit : L'horodatage (en anglais timestamping) est un mécanisme qui consiste à associer une date et une heure à un événement, une information ou une donnée informatique.
http://fr.wikipedia.org/wiki/Horodatage]
de la dernière modification du fichier ou répertoire à l'heure courante, information qu'on a déjà pu  découvrir avec la commande ls -l.

.Le tiret permet de retourner au répertoire courant précédent
[source, console]
----
$ date
Sat Apr 12 20:12:42 CEST 2014
$ ls -ld ~
drwxr-xr-x 59 titi titi 4096 avr 12 19:09 /home/titi
$ touch ~
$ ls -ld ~
drwxr-xr-x 59 titi titi 4096 avr 12 20:12 /home/titi
----

Ce qui nous intéressera, c'est que si lui donne en argument un fichier qui n'existe pas, il le crée (sans aucune informations – c'est un fichier vide).
C'est une commande pratique pour faire des exercices, et créer rapidement une série de fichiers.
